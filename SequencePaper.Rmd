---
title: "SequencePaper"
author: "Elizabeth Delmelle & Eric Delmelle"
date: "2024-09-03"
output:
  html_document:
    code_folding: hide
bibliography: "references.bib"
editor_options: 
  markdown: 
    wrap: 72
header-includes:
  - \usepackage{xcolor}
---


## Sequence Analysis of Neighborhood Racial and Ethnic Changes: The Case of New York City 1980-2020

### Introduction
  Tracking and understanding neighborhood changes has been a central topic of urban studies and a fundamental concern for planning practitioners
  [@Galster2001; @Landis2016; @ChappleZuk2016]. Neighborhood change can be comprehended according to various dimensions, from housing stock or built environment changes to residents' demographic and socioeconomic composition [@Delmelle2022].  Thus, the study of neighborhood change involves analyzing multiple attribute dimensions through time for spatially situated units. Recent scholarship has progressed in the analytical strategies used to study neighborhood trajectories, introducing new methods for visualizing and mapping longitudinal pathways of change for multiple dimensions [@Delmelle2022].

  In this article, we demonstrate one such technique, sequence analysis, to explore decennial neighborhood racial and ethnic changes in New York City from 1980-2020. The United States’ demographic profile has become increasingly diverse in the past several decades, driven by immigration and growing natural birth rates of the non-White population [@frey2022new]. Analyses following the release of the 2010 decennial census showed that increasing national diversity resulted in differing neighborhood trajectories, largely contingent on the broader metropolitan context [@Terbeck2023; @Wright2014].
  
  Much of the empirical scholarship on neighborhood racial and ethnic changes has developed indices to categorize the makeup or diversity of racial and ethnic groups and then explored changes in a neighborhood’s diversity categorization over time. For example, a neighborhood might transition from ‘low diverse’ to ‘moderately diverse’ from one decade to the next [@farrell2011racial; @Wright2014]. Alternately, another set of techniques aims to describe the longitudinal sequences or trajectories that the racial and ethnic groups in a neighborhood have followed. Two methods have been used for this purpose: statistical curve fitting and sequence analysis. With curve-fitting models like growth mixture models or latent growth models, mathematical functions fit each racial and ethnic group under study that summarize the predominant trends [@Zwiers2018; @HippKim2023]. With sequence analysis, neighborhoods are first grouped into similar clusters according to their racial and ethnic makeup using an unsupervised clustering algorithm like k-means. This is done for all neighborhoods and all time stamps. Then, each neighborhood is assigned a categorical cluster over time, and finally, the sequences of these clusters are grouped using a sequence alignment technique [@Delmelle2016; @GonzalezLeonardo2023]. Both approaches aim to develop a typology of the predominant longitudinal pathways of change for multiple variables at once.

  In this article, we explore trajectories of neighborhood racial and ethnic changes in the largest and one of the most diverse cities in the United States, New York City, using longitudinal census data up to the latest 2020 decennial release. This notebook showcases a workflow that introduces sequence analysis to the study of multidimensional neighborhood changes. We begin by processing the raw longitudinal census data, then performing a k-means classification, and finally classifying sequences clusters. 
  
### Computational environment 
  The main libraries used for this analysis include `dplyr` for processing tabular census data, `sf` for mapping the resulting clusters, `cluster` for performing the `k-means` cluster analysis. We also use `factoextra` and `pheatmap` for visualing and evaluating the clustering results. Finally, to perform the sequence analysis, we use `TraMineR` [@Gabadinho2011]. This is a popular and continually updated R package for performing sequence analysis for a host of social science applications, including analyses of neighborhood change [@Delmelle2016; @delmelle2017differentiating; @patias2020scalable]. 

```{r loadlibraries, include = FALSE}
# install.packages("tidyverse") # Install package if you have never used it before
library(tidyverse) #for data manipulation
# install.packages("cluster") # Install package if you have never used it before
library(cluster) # For k-means and hierarchical cluster analysis
# install.packages("dplyr") # Install package if you have never used it before
library(dplyr) # For data management
# install.packages("sf") # Install package if you have never used it before
library(sf) #For mapping sequence clusters
# install.packages("factoextra") # Install package if you have never used it before
library(factoextra) #For visualizing k-means outputs
# install.packages("ggplot") # Install package if you have never used it before
library(ggplot2) #For data visualization
# install.packages("pheatmap") # Install package if you have never used it before
library(pheatmap) # For creating heat map to describe k-means cluster results
# install.packages("TraMineR") # Install package if you have never used it before
library(TraMineR) #For sequence clustering
# install.packages("here") # Install package if you have never used it before
library(here) #for reading in data
# install.packages("tidycensus") # Install package if you have never used it before
library(tidycensus) #for reading in census tract data (shapefile)
# install.packages("knitr") # Install package if you have never used it before
library(knitr) #for data table formatting
# install.packages("gridExtra") # Install package if you have never used it before
library(gridExtra) #for facet plots
# install.packages("RColorBrewer") # Install package if you have never used it before
library(RColorBrewer) #for setting color palettes
```

### Data
  We use decennial census tract data to examine neighborhood racial and ethnic changes. Census tracts serve as imperfect, yet well-used neighborhood proxies. Census tract boundaries change over time, further complicating the study of population dynamics within these boundaries. There are several sources of data that have been harmonized using interpolation techniques to a consistent set of boundaries over time. We use the Longitudinal Tract Database (LTDB) which uses areal and population interpolation techniques alongside ancillary data on water cover to derive estimates [@logan2014interpolating]. Analyses of the errors produced by three popular longitudinal data providers suggest that LTDB performs similarly to the dataset produced by the National Historic Geographic Information System (NHGIS) and both perform better than the Neighborhood Change Database which relies solely on areal interpolation without the inclusion of ancillary data [@logan2014interpolating]. Therefore, for this type of analysis either the LTDB or NHGIS would be suitable dataset for this analysis.
  
  We obtained the fullcount decennial data from LTDB from 1980-2020 from the website (https://s4.ad.brown.edu/projects/diversity/Researcher/LTBDDload/DataList.aspx). The census variables have been interpolated to 2010 tract boundaries. Because the coding of census race and ethnicity changes over time, we opted to begin in 1980 as 1970, the earliest dataset available, did not record a count of Latino or Hispanic residents. The raw data contains all census tracts throughout the United States. Finally, we also import a shapefile of 2010 census tract boundaries using the `tidycensus` package and setting geometry to `true`.
  
### Basic conceptual intuition 
  Our analysis features two fundamental steps. The first is the *k*-means clustering of the census tracts to derive multidimensional classes of neighborhoods containing similar racial and ethnic compositions. [@reibel2011neighborhood] introduced the idea of using an unsupervised classification approach for studying neighborhood racial change as an alternative to the use of neighborhood diversity indices. The objective of the *k*-means algorithm is to group observations in such a way that maximizes the similarity of observations within groups or clusters while maximizing the dissimilarity between each cluster. In other words, the goal is to group neighborhoods so that those most similar to each other according to their racial and ethnic makeup are assigned to the same cluster and the clusters themselves are distinct from one another in terms of their makeup. With the *k*-means algorithm, the number of clusters, *k* must be determined *a priori*. To make this determination, it is customary to evaluate multiple solutions using various fit statistics in conjunction with domain and geographic knowledge of the data [@delmelle2015five]. It is also recommended that input variables be normalized for data used in neighborhood classification research to avoid placing unequal emphasis on variables that may be on different measurement scales. However, in our case study, all of the racial and ethnic variables represent percentages of the population and so, this step is not performed in the case study. 
  Our ultimate goal is to understand the major pathways of neighborhood change and so each neighborhood will be classified five times for 1980, 1990, 2000, 2010, and 2020 to establish its longitudinal sequence. To ensure that the clusters are temporally stable, we will perform the clustering for all years at once. New neighborhood typologies may emerge over time with this approach. In that case, only tracts from the later years would be assign to the new cluster.
  Like *k*-means, sequence analysis is an unsupervised classification technique that aims to cluster similar longitudinal sequences. To determine the similarity of the sequences, a key step in this analysis is to create the dissimilarity measure. There are various approaches that can be used to determine the similarity of categorical sequences. [@studer2016matters] provides a comprehensive overview of various techniques for determining sequences dissimilarity for social science applications. In this case study, we are most interested in the *ordering* or *sequencing* of neighborhood cross-sectional racial groups. Each neighborhood will have the same number of states, captured at the same decennial interval, which differs from studies of individuals progressing through a series of life course events, for example. In those cases, other considerations like the duration of time spent in each state or the timing of certain events may matter more in ultimately grouping the sequences based on similarity. However, in this case, we aim to create clusters of sequences that follow a similar ordering of events - progressing from example, a Majority White neighborhood through a Mixed Race state towards a Majority Hispanic state. The amount of time spent in each of these states might differ, but ultimately this describes *how* a neighborhood has changed over time. Given this, we follow [@delmelle2017differentiating] and use a variation on the popular Optimal Matching (OM) algorithm called OMstrans. The OM algorithm is a string editing technique that determines the cost it would take to completely transform one sequence into another. This is achieved by either inserting, deleting, or substituting elements in one sequence until it matches another. For example, one neighborhood may have a sequence of *White*, *White*, *Mixed Race*, *Hispanic* while another neighborhood might follow the sequence *White*, *White*, *Mixed Race*, *Mixed Race*. Between these two strings, there is one entry that differs: the final state. To transform one to another, we could substitute *Hispanic* for *Mixed Race* in the second sequence. In the OMstrans variant, distances between sequences of transitions are computed. This means that each state is merged with its previous state to create a subsequence. In the previous illustrative example, the first sequence becomes (*White-White*, *White-MixedRace*, *MixedRace-Hispanic*) and the OM cost evaluation is then applied to these subsequences. This helps to ensure that the ordering of events is preserved in the sequence clusters. The importance given to the preservation of ordering is governed by the parameter *w*, the origin-transition parameter. When *w* = 1, OMstrans approximates the traditional OM algorithm. A lower value places greater emphasis on the ordering or sequencing of events.
  

```{r importdata, warning=FALSE, cache = TRUE, message=FALSE}
here ()
#csv tables for longitudinal data
census20<- read.csv("data/ltdb_std_2020_fullcount.csv")
census10<- read.csv("data/LTDB_Std_2010_fullcount.csv")
census00<- read.csv("data/LTDB_Std_2000_fullcount.csv")
census90<- read.csv("data/LTDB_Std_1990_fullcount.csv")
census80<- read.csv("data/LTDB_Std_1980_fullcount.csv")
#geometry data
#filter for NYC counties (5 boroughs)
nyc_counties <- c("Kings", "Queens", "New York", "Richmond", "Bronx")
tract <- get_decennial(geography = "tract",
                       variables = "P001001",
                       year = 2010,
                       state = "NY",
                       county = nyc_counties,
                       geometry = TRUE)
```

```{r importdata_noeval, warning=FALSE, message=FALSE,cache = TRUE, eval = FALSE}
#filter for NYC counties (5 boroughs)
nyc_counties <- c("Kings", "Queens", "New York", "Richmond", "Bronx")
tract <- get_decennial(geography = "tract",
                       variables = "P001001",
                       year = 2010,
                       state = "NY",
                       county = nyc_counties,
                       geometry = TRUE)
```


  We next calculate the share of `White`, `Black`, `Hispanic`, and `Asian` residents in each tract for each decade from the raw count using the total population as the denominator. We filter out tracts where the population is `0` and select only the relevant columns to create our data frame. We then join all columns from the five decennial data frames into one data frame called `census_all` and finally select only census tracts from the five counties that comprise New York City's five boroughs: Bronx County, Kings County (Brooklyn), New York County (Manhattan), Queens County, Richmond County (Staten Island).
  
```{r calculatepercents, warning=FALSE, message=FALSE}
census80 <- census80 %>% filter (POP80 >0)
census80$perwhite80 <- census80$NHWHT80/census80$POP80
census80$perblack80 <- census80$NHBLK80/census80$POP80
census80$perhisp80 <- census80$HISP80/census80$POP80
census80$perasian80 <- census80$ASIAN80/census80$POP80
census80<- census80 %>% select(c("TRTID10","perwhite80", "perblack80", "perhisp80", "perasian80"))

census90 <- census90 %>% filter (POP90 >0)
census90$perwhite90 <- census90$NHWHT90/census90$POP90
census90$perblack90 <- census90$NHBLK90/census90$POP90
census90$perhisp90 <- census90$HISP90/census90$POP90
census90$perasian90 <- census90$ASIAN90/census90$POP90
census90<- census90 %>% select(c("TRTID10","state","county","perwhite90", "perblack90", "perhisp90", "perasian90"))

census00 <- census00 %>% filter (POP00 >0)
census00$perwhite00 <- census00$NHWHT00/census00$POP00
census00$perblack00 <- census00$NHBLK00/census00$POP00
census00$perhisp00 <- census00$HISP00/census00$POP00
census00$perasian00 <- census00$ASIAN00/census00$POP00
census00<- census00 %>% select(c("TRTID10","perwhite00", "perblack00", "perhisp00", "perasian00"))

census10 <- census10 %>% rename("TRTID10" = "tractid")
census10$perwhite10 <- census10$nhwht10/census10$pop10
census10$perblack10 <- census10$nhblk10/census10$pop10
census10$perhisp10 <- census10$hisp10/census10$pop10
census10$perasian10 <- census10$asian10/census10$pop10
census10<- census10 %>% select(c("TRTID10","perwhite10", "perblack10", "perhisp10", "perasian10"))

census20 <- census20 %>% rename("TRTID10" = "TRTID2010")
census20$perwhite20 <- census20$nhwt20/census20$pop20
census20$perblack20 <- census20$nhblk20/census20$pop20
census20$perhisp20 <- census20$hisp20/census20$pop20
census20$perasian20 <- census20$asian20/census20$pop20
census20<- census20 %>% select(c("TRTID10","perwhite20", "perblack20", "perhisp20", "perasian20"))

#join all data frames from each decade
census_all<- census90 %>% left_join(census00) %>% left_join(., census10) %>% left_join(., census20)%>% left_join(., census80)

#Select NYC Counties. These include Bronx County, Kings County (Brooklyn), New York County (Manhattan), Queens County, Richmond County (Staten Island)

census_select <- census_all %>% filter((state == "NY" & county == "Bronx County")|
                              (state == "NY" & county == "Kings County")|
                              (state == "NY" & county == "New York County")|
                              (state == "NY" & county == "Queens County")|
                              (state == "NY" & county == "Richmond County"))

##remove NA values and state and county columns
census_nyc <- na.omit(census_select)%>% select(-state, -county)

#Select only the tractID column from the shapefile. Rename the field for ease of joining and convert to double to match the csv data.
tract<- tract %>% select("GEOID")
tract<- rename(tract, TRTID10 = GEOID)
tract$TRTID10<- as.double(tract$TRTID10)


```

  We next prepare the data for the k-means clustering. This involves pivoting the data frame so that each census tract is represented with five distinct rows, once for each decennial value. To do so, we pivot from a wide to a long format and select out just the four race and ethnicity values to be used in the clustering.
```{r kmeans, warning=FALSE, message=FALSE}
# Convert the data frame from wide to long format
census_long <- census_nyc %>%
  pivot_longer(cols = starts_with("per"), 
               names_to = c(".value", "year"), 
               names_pattern = "per(\\w+)(\\d{2})") %>%
  mutate(year = case_when(
    year == "80" ~ 1980,
    year == "90" ~ 1990,
    year == "00" ~ 2000,
    year == "10" ~ 2010,
    year == "20" ~ 2020,
    TRUE ~ as.integer(year)
  ))


data_for_clustering <- census_long %>%
  select(white, black, hisp, asian)


```

  As explained above, the *k* means clustering procedure requires that the number of clusters, *k* be specified *a priori*. There are fit statistics that attempt to determine the optimal number of clusters, considering the similarity of observations within each cluster and the distinctiveness of the clusters from each other. However, these mathematically-derived solutions are devoid of any contextual or theoretical understanding of the problem under study. Therefore, the selection of *k* often becomes more akin to art than a science [@von2012clustering], considering the objective of the study. We begin with two common data-driven approaches that explore multiple clustering solutions for different *k* values and then examines the *within sum of squares* (WSS) and the *average silhouette score* for each solution. The WSS assesses how compact a clustering solution is, or how homogeneous the observations assigned to each cluster are, and the average silhouette score measures how well separated each cluster is from each other. Our objective is to derive a typology of neighborhoods according to their racial and ethnic makeup, for four groups: percent White, Black, Hispanic, and Asian.

```{r kmeans1, warning=FALSE, message=FALSE}
##Now do the k-means clustering on all

data_for_clustering <- census_long %>%
  select(white, black, hisp, asian)

# Function to calculate total within-cluster sum of squares for different k
wss <- function(k) {
  kmeans(data_for_clustering, k, nstart = 10)$tot.withinss
}


# Compute and plot wss for k = 1 to k = 10
k.values <- 1:10
wss_values <- map_dbl(k.values, wss)

# Elbow method plot
plot(k.values, wss_values, type = "b", pch = 19, frame = FALSE,
     xlab = "Number of clusters K",
     ylab = "Total within-clusters sum of squares")

# Silhouette method for determining the optimal number of clusters
fviz_nbclust(data_for_clustering, kmeans, method = "silhouette")

```


#### Exploring *k*-means Cluster Solutions

  According to these plots, the mathematically optimal number of neighborhood clusters for racial makeup is three. We can further explore the makeup of neighborhoods within these three clusters a few ways to determine if, in fact, three clusters provides a meaningful segmentation of four distinct racial and ethnic groups. In the plots below, we can visualize the average silhouette value for each cluster. The Silhouette values range from -1 to 1; values close to 1 suggest that the observations are well clustered while negative values are indicative that an observation might be assigned to the wrong cluster. From the plot, Clusters 2 and 3 appears to be the most cohesive cluster, with average silhouette widths of 0.64 while cluster 1 has some potential poorly classified neighborhoods. Descriptions of the racial and ethnic makeup of the clusters are obtained from the Table should the Cluster Profiles and associated stacked bar charts. We can see that Cluster 1 is characterized as being nearly 50 percent Hispanic, with near equal shares of Whites, Blacks, and Asians. Cluster 2 is majority Black with approximately 15 percent Hispanics and few Whites and Asians. Finally, Cluster 3 is majority White. Therefore, this segmentation provides us with clusters indicating the dominant racial groups, but may miss some nuances of other racial and ethnic neighborhood compositions. We can therefore explore how these distributions may portray a richer portrait of neighborhood demographic profiles by increasing the number of clusters. 

```{r threeclusters, warning=FALSE, message=FALSE}
# Assume the optimal number of clusters (k) is 3 from the previous steps
set.seed(123)
kmeans_result <- kmeans(data_for_clustering, centers = 3, nstart = 25)

# Add the cluster assignments to the original data
census_long$cluster <- kmeans_result$cluster


# Silhouette Analysis
sil <- silhouette(kmeans_result$cluster, dist(data_for_clustering))
fviz_silhouette(sil)

# Extract silhouette information into a data frame
sil_df <- as.data.frame(sil[, 1:3])
colnames(sil_df) <- c("Cluster", "Silhouette Width", "Neighboring Cluster")


# Cluster profiles
cluster_profiles <- census_long %>%
  group_by(cluster) %>%
  summarise(across(c(white, black, hisp, asian), ~ round(mean(.), 2)))


# Print the table as a formatted table
kable(cluster_profiles, caption = "Cluster Profiles: Average Demographics", 
      col.names = c("Cluster", "White", "Black", "Hispanic", "Asian"),
      format = "markdown")

# Step 1: Reshape the data from wide to long format
cluster_profiles_long <- cluster_profiles %>%
  pivot_longer(cols = c("white", "black", "hisp", "asian"), 
               names_to = "Demographic", values_to = "Proportion")

# Step 2: Create the stacked bar chart
ggplot(cluster_profiles_long, aes(x = factor(cluster), y = Proportion, fill = Demographic)) +
  geom_bar(stat = "identity") +
  labs(title = "Cluster Demographic Makeup - 3 clusters", x = "Cluster", y = "Proportion") +
  scale_fill_brewer(palette = "Set3") +  # Adjust color palette if desired
  theme_minimal()


```

  Here, we compare 4,5,and 6 cluster solutions. We can see that the average silhouette of the solutions declines as the number of clusters increases. The demographic profiles show several new neighborhood typologies emerge with more clusters added. With a four cluster solution, we observe neighborhood typologies for each of the three dominant racial and ethic groups: White, Hispanic, and Black along with one mixed neighborhood type, shown in cluster 4. As expected, that cluster displays the lowest silhouette value, with some potentially mis-classified neighborhoods. The 5 cluster solution adds a cluster showing a majority Asian population, alongside two majority White populations - one showing more diversity than the other), and a majority Black, and Hispanic group. Finally, a 6 cluster solution shows more racially mixed groups, but at the expense of less well-defined or separated clusters. 
 
  
```{r exploreclusters, warning=FALSE, message=FALSE}
# Perform k-means clustering for 4, 5, and 6 clusters
set.seed(123)
kmeans_4 <- kmeans(data_for_clustering, centers = 4, nstart = 25)
kmeans_5 <- kmeans(data_for_clustering, centers = 5, nstart = 25)
kmeans_6 <- kmeans(data_for_clustering, centers = 6, nstart = 25)

# Add cluster assignment to original data
census_long$cluster_4 <- kmeans_4$cluster
census_long$cluster_5 <- kmeans_5$cluster
census_long$cluster_6 <- kmeans_6$cluster

# Silhouette analysis for 4, 5, and 6 clusters
sil_4 <- silhouette(kmeans_4$cluster, dist(data_for_clustering))
sil_5 <- silhouette(kmeans_5$cluster, dist(data_for_clustering))
sil_6 <- silhouette(kmeans_6$cluster, dist(data_for_clustering))

# Plot silhouette for 4 clusters
plot_4 <- fviz_silhouette(sil_4) + ggtitle("Silhouette Plot - Four Clusters")

# Plot silhouette for 5 clusters
plot_5 <- fviz_silhouette(sil_5) + ggtitle("Silhouette Plot - Five Clusters")

# Plot silhouette for 6 clusters
plot_6 <- fviz_silhouette(sil_6) + ggtitle("Silhouette Plot - Six Clusters")

# Combine the three plots into a faceted view
grid.arrange(plot_4, plot_5, plot_6, ncol = 1)


# Cluster profiles for 4, 5, and 6 clusters
cluster_profiles_4 <- census_long %>%
  group_by(cluster_4) %>%
  summarise(across(c(white, black, hisp, asian), ~ round(mean(.), 2))) %>%
  mutate(clusters = "4")

cluster_profiles_5 <- census_long %>%
  group_by(cluster_5) %>%
  summarise(across(c(white, black, hisp, asian), ~ round(mean(.), 2))) %>%
  mutate(clusters = "5")

cluster_profiles_6 <- census_long %>%
  group_by(cluster_6) %>%
  summarise(across(c(white, black, hisp, asian), ~ round(mean(.), 2))) %>%
  mutate(clusters = "6")

# Combine cluster profiles into one table
cluster_profiles_combined <- bind_rows(cluster_profiles_4, cluster_profiles_5, cluster_profiles_6)


# Reshape data for the stacked bar chart
cluster_profiles_long_combined <- cluster_profiles_combined %>%
  pivot_longer(cols = c("white", "black", "hisp", "asian"), 
               names_to = "Demographic", values_to = "Proportion")



# Remove rows with NA cluster assignments (from clusters 4, 5, and 6)
cluster_profiles_long_combined <- cluster_profiles_combined %>%
  pivot_longer(cols = c("cluster_4", "cluster_5", "cluster_6"),
               names_to = "Clustering Solution", values_to = "Cluster") %>%
  filter(!is.na(Cluster)) %>%  # Remove NA rows
  pivot_longer(cols = c("white", "black", "hisp", "asian"),
               names_to = "Demographic", values_to = "Proportion")



# Plot with corrected cluster assignments
ggplot(cluster_profiles_long_combined, aes(x = factor(Cluster), y = Proportion, fill = Demographic)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ `Clustering Solution`, ncol = 1) +  # Facet by clustering solution (4, 5, 6 clusters)
  labs(title = "Cluster Demographic Makeup for 4, 5, and 6 Clusters", 
       x = "Cluster", y = "Proportion") +
  scale_fill_brewer(palette = "Set3") +
  theme_minimal()



```
  
  
To coarsely summarize the distinction between the resulting clusters: 
  
  
  **Four Cluster Solution**
  
  1. Majority Black
  
  2. Mixed Race
  
  3. Majority White
  
  4. Majority Hispanic
  
  **Five Cluster Solution**
  
  1. Majority Hispanic
  
  2. Majority White
  
  3. Majority Asian
  
  4. Majority Black
  
  5. White. Mixed-Race
  
  **Six Cluster Solution**
  
  1. White, Mixed-Race
  
  2. Black & Hispanic
  
  3. Majority Asian
  
  4. Majority Hispanic
  
  5. Majority Black
  
  6. Majority White

  We can explore how this plays out for a specific observation. For example, take the first census tract in the data frame for the year `2020`. We can see that the racial composition was `58%` Black and `30%` Hispanic with small shares of Whites and Asians. With the four cluster solution, this tract was classified into class 1, `Majority Black`. For the five cluster solution, it was also classified as `Majority Black`, and for the six cluster solution, `Black and Hispanic`. In 1990, that same tract was `34%` black and `61%` Hispanic, resulting in the tract being classified as `Majority Hispanic` by all three clustering solutions. When looking at change over time, the neighborhood will either be registered as transitioning from `Majority Hispanic` to either `Majority Black` or `Black and Hispanic`, depending on the final cluster solution. In this instance, the 6 cluster solution provides a more accurate portrayal of the dynamics - while the neighborhood did technically become majority Black, there is still a significant Hispanic presence, a detail that would have been omitted by limiting the number of groups.
  
  Finally, we can examine the spatial distribution of these clustering solutions to help aid in the final determination for the sequence analysis. Since we did the cluster analysis on all decades, for this purpose, we will contrast the 4, 5, and 6 cluster solutions just for 2020. All three maps depict a similar spatial pattern, but with a more fragmented pattern in the case of the 6 cluster solution. 
  To better understand details on racial neighborhood transitions, we will go with the larger number of clusters, 6, despite the mathematical preference for a 3 cluster solution.
  
```{r mappingclusters}
# Filter data for the year 2020
tract_clusters_2020 <- tract %>%
  left_join(census_long %>%
              filter(year == 2020) %>%  # Filter for the year 2020
              select(TRTID10, cluster_4, cluster_5, cluster_6), by = "TRTID10") %>%
  pivot_longer(cols = c("cluster_4", "cluster_5", "cluster_6"),
               names_to = "ClusterSolution", values_to = "Cluster") %>%
  filter(!is.na(Cluster))  # Remove NA values

# Set the levels for the ClusterSolution to ensure the correct facet order
tract_clusters_2020 <- tract_clusters_2020 %>%
  mutate(ClusterSolution = recode(ClusterSolution,
                                  "cluster_4" = "Four Clusters",
                                  "cluster_5" = "Five Clusters",
                                  "cluster_6" = "Six Clusters")) %>%
    mutate(ClusterSolution = factor(ClusterSolution, levels = c("Four Clusters", "Five Clusters", "Six Clusters")))
#set consistent color palette to also be used in the sequence clutering
pal <- c("#8DD3C7", "#FFFFB3", "#BEBADA","#FB8072", "#80B1D3","#FDB462")

# Plot the faceted maps for 2020 clusters
ggplot(tract_clusters_2020) +
  geom_sf(aes(fill = factor(Cluster)), color = NA) +  # Use factor to ensure proper color assignment
  facet_wrap(~ ClusterSolution, ncol = 3) +  # Facet by clustering solution (Four, Five, Six Clusters)
  scale_fill_manual(values = pal, name = "Cluster") +  
  labs(title = "Cluster Solutions for 4, 5, and 6 Clusters (2020)", x = "", y = "") +
  theme_void() +
  theme(legend.position = "bottom",
        legend.direction = "horizontal",
        legend.title = element_text(size=10),
        legend.key.width = unit(2, "cm"))


```
  

  We can begin with a simple exploration of the spatial changes over time in the maps showing the six clusters from 1980-2020 in a series of small multiples. From these maps, we can pick out some general spatial patterns over time. For example, we can see the expanse of neighborhoods classified as majority White from 1980 significantly diminishes by 2020. The share of Hispanics is shown to increase over time in the northern sections of the City. Towards the East, we see neighborhoods generally transition from predominantly White in 1980 to White and Mixed Race and eventually to Asian by 2020. 
  There are also some evident stable clusters. For instance, the two clusters of predominantly black neighborhoods in the South and Southeast appear quite table over time. However, the cluster of majority Black neighborhoods in towards the north of Manhattan nearly disssapears, replaced by a Black and Hispanic classification.  
  
  
```{r smallmultiples}

decades <- c(1980, 1990, 2000, 2010, 2020)


# Filter and prepare data for mapping
tract_clusters_decades <- tract %>%
  left_join(census_long %>%
              select(TRTID10, year, cluster_6), by = "TRTID10") %>%
  filter(!is.na(cluster_6))  %>%
  mutate(cluster_6 = recode(cluster_6,
                            `1` = "White Mixed Race",
                            `2` = "Black & Hispanic",
                            `3` = "Asian",
                            `4` = "Hispanic",
                            `5` = "Black",
                            `6` = "White"))

# Set factor levels for year to ensure proper ordering
tract_clusters_decades <- tract_clusters_decades %>%
  mutate(year = factor(year, levels = decades))

# Plot faceted maps for each decade (year)
ggplot(tract_clusters_decades) +
  geom_sf(aes(fill = factor(cluster_6)), color = NA) +  # Use factor to ensure proper color assignment
  facet_wrap(~ year, ncol = 5) +  # Facet by year with 2 columns for better layout
  scale_fill_manual(values = pal, name = "Cluster") +  # Same color palette as before
  labs(title = "6-Cluster Solution for Each Decade", x = "", y = "") +
  theme_void() +
  theme(legend.position = "bottom",  # Move legend to bottom
        legend.direction = "horizontal",  # Make the legend horizontal
        legend.title = element_text(size = 10),  # Adjust legend title size if needed
        legend.key.width = unit(2, "cm"))  # Adjust legend width for readability

```

  Our objective with the sequence classification is to come up with a typology of neighborhood sequences over time to describe general pathways of change. Each neighborhood has a sequence of classes over time, one for each of the five decennial census values from 1980-2020. The first step in the analysis is to convert the data frame into a sequence for each neighborhood. We can see an illustrative example of the longitudinal sequences from the first five records. Classes are separated by a dash (-). There are 2122 sequences in the dataset and 197 unique sequences; all sequences are displayed in the plot below.
  
```{r createsequences, warning=FALSE, message=FALSE}
#Now convert to wide format so we have a sequence for each neighborhood
# Assuming census_long is your data frame
# Convert the data from long to wide format
census_wide <- tract_clusters_decades %>%st_drop_geometry%>%
  select(TRTID10, year, cluster_6) %>%
  pivot_wider(names_from = year, values_from = cluster_6, names_prefix = "cluster_")

census_wide <- census_wide %>%
  select(TRTID10, cluster_1980, cluster_1990, cluster_2000, cluster_2010, cluster_2020)

# Ensure the sequence columns are factors
census_wide <- census_wide %>%
  mutate(across(starts_with("cluster_"), as.factor))

# Define the sequences
sequence_data <- seqdef(census_wide[, -1], cpal = pal)  # Exclude the TRTID10 column

# number of distinct sequences
seqtab(sequence_data, idx=0) %>% nrow

head(sequence_data)

seqIplot(sequence_data,                                             # Sequence object
         with.legend = "right",                                # Display legend on right side of plot
         cex.legend = 0.6,                                     # Change size of legend
         main = "Neighborhood Racial and Ethnic Trajectories") # Plot title


```
  
  The next objective is to compute the dissimilarity between all sequences. As described previously, we use the OMstrans algorithm to preserve the ordering of events as we are most interested in describing how neighborhoods have generally transitioned over time. We set a low value (`0.1`) for the parameter `otto` in the `seqdist` command which is the origin-transition trade-off weight. This emphasizes the ordering of sequence states. We also set a high `indel` cost of `3`. Finally, substitution costs are a function of the transition rate `TRATE` between states. This places a lower cost on more frequent transitions. 
  Once the cost matrix is established, we then cluster the sequences using the dissimilarity matrix as an input to generate the typology. We follow an iterative process in determining the optimal solution like the one described above for the *k* means clustering. In short, multiple solutions are tested and the resulting sequence clusters are visualized to inspect for heterogeneity. Because our clustering and distance matrix are optimized for describing transitions over time, we end up with one cluster that contains all neighborhoods that remained constant over time. These sequences are very different from one another, but they all represent no change. When we get to the mapping stage, we will separate out each of these distinct cases to identify sequences of remaining in each of the six neighborhood categories. 
  To describe the resulting sequence clusters, we plot a Sequence Frequency Plot for each cluster. We settled on 14  trajectory clusters describing neighborhood racial and ethnic transitions from 1980 to 2020 in New York City. The Sequence Frequency Plots illustrate the sequences belonging to each cluster and the sequence bars are scaled to visualize the frequency of each sequence. A summary of the trajectories is as follows:
  
  1. Hispanic Majority to Black and Hispanic
  2. Stability Cluster
  3. White and Mixed Race to Hispanic Majority
  4. White to White and Mixed Race to Hispanic Majority
  5. Black and Hispanic to Hispanic Majority
  6. White Majority to White and Mixed Race
  7. White and Mixed Race to Black and Hispanic
  8. Black and Hispanic to Black Majority
  9. White and Mixed Race to Asian Majority
  10.  White and Mixed Race to White Majority
  11. Black and Hispanic to White and Mixed Race 
  12. White and Mixed Race to Asian Majority
  13. Black Majority to Black and Hispanic
  14. Black and Hispanic to Asian Majority
  

  

```{r clustersequences, message = FALSE}

# Compute the OM distances
costs <- seqcost(sequence_data, method = "TRATE")
om_distances <- seqdist(sequence_data, method = "OMstran", indel = 3, sm = costs$sm, otto = 0.1)

clusterward <- agnes(om_distances, diss = TRUE, method = "ward")

# Adjust the plotting parameters
#op <- par(mar = c(5, 5, 4, 2) + 0.1)  # Adjust margins as needed

# Choose the number of clusters (e.g., 4)
num_clusters <- 14
clusters <- cutree(clusterward , k = num_clusters)

# Add the cluster assignments to the original data
census_wide$sequence_cluster <- clusters


# Plot the sequences for each cluster. to make things fit, lets do five at a time

# Plot only for clusters 1 to 5 using simple indexing
cluster_names1 <- c("1 Black & Hispanic to Hispanic Majority", 
                   "2 Stablility", 
                   "3 White Mixed Race to Hispanic", 
                   "4 White to Mixed Race to Hispanic Majority", 
                   "5 Majority White to Increasing Diversity")


seqfplot(sequence_data[census_wide$sequence_cluster %in% 1:2, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 1:2], 
         sortv = "from.start", 
         border = NA, 
         with.legend = FALSE)


seqfplot(sequence_data[census_wide$sequence_cluster %in% 3:4, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 3:4], 
         sortv = "from.start", 
         border = NA, 
         with.legend = FALSE)


seqfplot(sequence_data[census_wide$sequence_cluster %in% 5:6, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 5:6], 
         sortv = "from.start", 
         border = NA, 
         with.legend = FALSE)


seqfplot(sequence_data[census_wide$sequence_cluster %in% 7:8, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 7:8], 
         sortv = "from.start", 
         border = NA, 
         with.legend = FALSE)


seqfplot(sequence_data[census_wide$sequence_cluster %in% 9:10, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 9:10], 
         sortv = "from.start", 
         border = NA, 
         with.legend = FALSE)


seqfplot(sequence_data[census_wide$sequence_cluster %in% 11:12, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 11:12], 
         sortv = "from.start", 
         border = NA, 
         with.legend = FALSE)


seqfplot(sequence_data[census_wide$sequence_cluster %in% 13:14, ], 
         group = census_wide$sequence_cluster[census_wide$sequence_cluster %in% 13:14], 
         sortv = "from.start", 
         border = NA, 
         with.legend = TRUE)


```

    Of these 14 pathways, there are 3 that lead to the formation of a neighborhood transitioning into a Hispanic Majority cluster by 2020. This includes Cluster 3 - showing neighborhoods that went from being a slight majority White, but with a mixture of other races in 1980 and 1990 to transitioning to majority Hispanic by 1990 or 2000. Some of these sequences indicate a continued transition towards becoming majority Asian in the later years. Further segmenting the sequences into more clusters may have separated out those trajectories, but for the sake of brevity, we leave them mixed in. Spatially, these are shown in Orange on the map below and can be see clustered in Staten Island, Queens, and in the Northern portion of the city. They are also notably adjacent to neighborhoods indicated by the red color, those representing sequence cluster 4, transitioning from majority White to White and Mixed Race and then to Majority Hispanic. This latter cluster might reprent the precursor to cluster 3, but are neighborhoods that made this transition from majority White later, where the changes took time to spatially spillover to adjacent neighborhoods, as indicated by the map. Both of these pathways depict a transition from largely White populations to largely Hispanic.
    The third pathway depicting a transition to majority Hispanic is distinct. It is represented by cluster 5 showing a transition from either majority Black neighborhoods towards a mixed Hispanic and Black group and eventually majority Hispanic or beginning the 1980 time stamp in a more mixed Black and Hispanic state. Geographically, these neighborhoods are shown more in the northern sections of Manhattan and the Bronx.
    
```{r HispanicMajorityMap}
# Load necessary libraries
library(ggplot2)
library(sf)
library(dplyr)

# Filter census data to include only clusters 4, 5, and 6
hispanic_majority_clusters <- census_wide %>%
  filter(sequence_cluster %in% c(4, 5, 6))  # Clusters 4, 5, 6 represent Hispanic Majority pathways

# Join the filtered data with the tract shapefile based on TRTID10
tract_hispanic_majority <- tract %>%
  left_join(hispanic_majority_clusters, by = "TRTID10")  # Join with spatial data

# Create a map of the neighborhoods with clusters 4, 5, and 6 with new labels
ggplot(tract_hispanic_majority) +
  geom_sf(aes(fill = factor(sequence_cluster)), color = NA) +  # Map sequence clusters
  scale_fill_manual(values = c("#FB8072", "#80B1D3", "#FDB462"),  # Custom color palette
                    labels = c("3 White - White, Mixed Race - Hispanic", 
                               "5 Black - Black & Hispanic - Hispanic", 
                               "4 White, Mixed Race - Hispanic"), 
                    name = "Hispanic Majority Pathway") +
  labs(title = "Neighborhoods Following Pathway to Hispanic Majority", 
       x = "", y = "") +
  theme_void() +
  theme(legend.position = "right",  # Place legend at the bottom
        legend.direction = "vertical",  # Arrange legend items horizontally
        legend.title = element_text(size = 12),  # Customize legend title size
        legend.key.width = unit(2, "cm"),  # Adjust legend key width
        legend.box = "vertical")  # Place legend title on top of the legend


```
  
  There are also 3 pathways leading to an Asian majority neighborhood type. These include clusters 9 and 12 which are also likely continuations of longer trajectories showing a gradual transition from Majority White to White mixed race and eventually to Asian Majority. Geographically, these are clustered in the northern section of Queens. Sequence cluster 14 is more distinct in that the Asian majority transitioned from the Black and Hispanic mixed group and spatially, they are generally located in upper Manhattan and the Bronx.
  
```{r AsianPathways}

# Filter census data to include only clusters 14, 12, and 9 (Asian Majority Pathway clusters)
asian_majority_clusters <- census_wide %>%
  filter(sequence_cluster %in% c(14, 12, 9))  # Clusters 14, 12, and 9 represent Asian Majority pathways

# Join the filtered data with the tract shapefile based on TRTID10
tract_asian_majority <- tract %>%
  left_join(asian_majority_clusters, by = "TRTID10")  # Join with spatial data

# Create a map of the neighborhoods with clusters 14, 12, and 9 with new labels
ggplot(tract_asian_majority) +
  geom_sf(aes(fill = factor(sequence_cluster)), color = NA) +  # Map sequence clusters
  scale_fill_manual(values = c("#8DD3C7", "#FFFFB3", "#BEBADA"),  # Custom color palette for Asian Majority clusters
                    labels = c("14 White, Mixed Race to Black & Hispanic to Asian Majority", 
                               "12 White Majority to White Mixed Race to Asian", 
                               "9 White Mixed Race to Asian"), 
                    name = "Asian Majority Pathway") +
  labs(title = "Neighborhoods Following Pathway to Asian Majority", 
       x = "", y = "") +
  theme_void() +
  theme(legend.position = "right",  # Place legend at the bottom
        legend.direction = "vertical",  # Arrange legend items horizontally
        legend.title = element_text(size = 12),  # Customize legend title size
        legend.key.width = unit(2, "cm"),  # Adjust legend key width
        legend.box = "vertical")  # Place legend title on top of the legend

```
  

  There are two pathways for increasing both Black and White shares in a neighborhoods. Neighborhoods that became increasingly White either followed a trajectory from White mixed race to majority White (Cluster 10) or from either all Black or Black and Hispanic to White and Mixed race (11). Notablly, this transition largely took place within the past 1-2 decades, aligning with when gentrification trends became accentuated in some cities, including New York. We see a clear cluster of this latter group in Brooklyn, a borough whose gentrification trends have been well documented [@chronopoulos2020s; @halasz2023between]. For the case of increasing Black populations, cluster 1 shows a pathway from Hispanic majority to mixed Black and Hispanic and Cluster 8 shows a gradual transition from Black and Hispanic to majority Black; a trend that largely begin towards the middle of the study period, around the 2000 census data mark. Spatially, the former is more dispersed, while the latter is depcited more clearly in the 
  
  
```{r whiteandblack}
library(patchwork)  # Optional for arranging multiple plots side by side

# Filter data for Increasing White (clusters 10 and 11)
increasing_white_clusters <- census_wide %>%
  filter(sequence_cluster %in% c(10, 11))  # Clusters 10 and 11 for increasing White

# Filter data for Increasing Black (clusters 1 and 8)
increasing_black_clusters <- census_wide %>%
  filter(sequence_cluster %in% c(1, 8))  # Clusters 1 and 8 for increasing Black

# Join the filtered data with the tract shapefile for each group
tract_increasing_white <- tract %>%
  left_join(increasing_white_clusters, by = "TRTID10")  # Join spatial data for increasing White

tract_increasing_black <- tract %>%
  left_join(increasing_black_clusters, by = "TRTID10")  # Join spatial data for increasing Black

# Create the map for Increasing White
map_increasing_white <- ggplot(tract_increasing_white) +
  geom_sf(aes(fill = factor(sequence_cluster)), color = NA) +  # Map sequence clusters
  scale_fill_manual(values = c("#8DD3C7", "#FFFFB3"),  # Custom color palette for White clusters
                    labels = c("White Mixed Race to Majority White", 
                               "Black and Hispanic to White Mixed Race"), 
                    name = "Increasing White Pathway") +
  theme_void() +
  theme(legend.position = "right",  # Place legend at the bottom
        legend.direction = "vertical",  # Arrange legend items horizontally
        legend.title = element_text(size = 12),  # Customize legend title size
        legend.key.width = unit(2, "cm"),
        legend.box = "vertical")  # Place legend title on top

# Create the map for Increasing Black
map_increasing_black <- ggplot(tract_increasing_black) +
  geom_sf(aes(fill = factor(sequence_cluster)), color = NA) +  # Map sequence clusters
  scale_fill_manual(values = c("#FB8072", "#80B1D3"),  # Custom color palette for Black clusters
                    labels = c("Hispanic Majority to Black & Hispanic", 
                               "Black and Hispanic to Black Majority"), 
                    name = "Increasing Black Pathway") +
  theme_void() +
  theme(legend.position = "right",  # Place legend at the bottom
        legend.direction = "vertical",  # Arrange legend items horizontally
        legend.title = element_text(size = 12),  # Customize legend title size
        legend.key.width = unit(2, "cm"),
        legend.box = "vertical")  # Place legend title on top

# Combine the two maps side by side using patchwork
combined_map <- map_increasing_white + map_increasing_black + plot_layout(ncol = 2)

# Print the combined map
print(combined_map)
```


#### Sources.
